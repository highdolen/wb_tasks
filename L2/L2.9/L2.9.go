package main

import (
	"errors"
	"fmt"
	"unicode"
)

// Unpack возвращает ошибку при некорректной строке (например, начинается с цифры)
func Unpack(input string) (string, error) {
	// если вход пустой — сразу возвращаем пустую строку без ошибки
	if input == "" {
		return "", nil
	}

	// преобразуем входную строку в срез рун
	runes := []rune(input)

	// result будет содержать итоговые руны (результат распаковки)
	var result []rune

	// prev хранит предыдущий «обычный» символ (тот, который может быть повторён цифрой)
	var prev rune

	// escaped указывает, что предыдущий символ был '\' и текущая руна должна трактоваться буквально
	escaped := false

	// проходим по всем рунам исходной строки по индексу i.
	for i := 0; i < len(runes); i++ {
		// r — текущая руна на позиции i.
		r := runes[i]

		// если активирован режим экранирования (предыдущая была '\'),
		// то текущую руну нужно добавить как обычный символ
		if escaped {
			// запомним текущую руну как предыдущую (на неё могут ссылаться последующие цифры)
			prev = r
			// добавляем текущую руну в результат буквально
			result = append(result, prev)
			// сбрасываем режим экранирования — он действует только на один символ
			escaped = false
			// переходим к следующей итерации цикла
			continue
		}

		// если текущая руна — обратный слэш, включаем режим экранирования
		// и не добавляем сам '\' в результат
		if r == '\\' {
			escaped = true
			continue
		}

		// если текущая руна — цифра, она задаёт количество повторов предыдущего символа
		if unicode.IsDigit(r) {
			// если предыдущего символа нет (например, строка начинается с цифры) — это ошибка
			if prev == 0 {
				return "", errors.New("invalid string: digit without previous character")
			}

			// преобразуем руну в целое число
			count := int(r - '0')

			// если число равно 0, то по условию удаляем предыдущий символ из результата
			if count == 0 {
				if len(result) > 0 {
					// удаляем последний добавленный элемент (предыдущий символ)
					result = result[:len(result)-1]
				}
			} else {
				// если count > 0: один символ prev уже добавлен ранее,
				// поэтому добавляем ещё (count-1) копий prev
				for j := 1; j < count; j++ {
					result = append(result, prev)
				}
			}
			// после обработки цифры переходим к следующему символу.
			continue
		}

		// обычный (не-экранированный и не-цифровой) символ
		// запоминаем его в prev и добавляем в результат
		prev = r
		result = append(result, prev)
	}

	// если цикл завершился, но флаг escaped всё ещё true, значит строка закончилась '\', то ошибка
	if escaped {
		return "", errors.New("invalid string: ends with escape")
	}

	// преобразуем срез рун обратно в строку и возвращаем.
	return string(result), nil
}

func main() {
	// Набор тестовых входных строк для демонстрации работы.
	tests := []string{
		"a4bc2d5e", // обычный пример с цифрами
		"abcd",     // без цифр
		"45",       // ошибка: цифра без предыдущего символа
		"",         // пустая строка
		`qwe\4\5`,  // экранирование: должны получить "qwe45"
		`qwe\45`,   // \4 = '4', затем 5, поэтому '4' повторяется 5 раз
		"aaa0b",    // 'a' с 0 удаляет предыдущий 'a'
		`a\\b`,     // двойной слэш, первый экранирует второй, поэтому в результате "a\b"
		"\\",       // только слэш — ошибка (заканчивается экранированием)
	}

	// пробегаем тесты и печатаем результат или ошибку
	for _, input := range tests {
		out, err := Unpack(input) // вызываем нашу функцию распаковки
		if err != nil {
			// если есть ошибка — печатаем её вместе со входной строкой
			fmt.Printf("Input: %q -> ERROR: %v\n", input, err)
		} else {
			// иначе показываем распакованную строку.
			fmt.Printf("Input: %q -> Output: %q\n", input, out)
		}
	}
}
